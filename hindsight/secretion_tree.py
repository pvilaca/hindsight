"""Calculate the tree of all possible secretions if fermentation products are
sequentially knocked out.

"""

from hindsight import (load_models_to_compare, get_secretion, setup_for_series,
                       apply_design, apply_environment, error_series,
                       me_optimize_growth, Design, SimulationSetup)
from hindsight.variables import min_biomass, SetUpModelError
from parallel_pandas import apply_p
from theseus import load_model

import pandas as pd
idx = pd.IndexSlice
import numpy as np
from collections import namedtuple
import sys
from os.path import join, exists

Secretions = namedtuple('Secretions', [
    'knockouts', # iterable
    'growth_rate', # float
    'exchange_reactions', # iterable
    'fluxes', # iterable with same order as exchange reactions
])
Secretions.__repr__ = lambda self: '<Secretions {self.knockouts}, {self.growth_rate:.3f}, {self.exchange_reactions}, {self.fluxes} >'.format(self=self)

class FoundReaction(Exception):
    pass

def run_secretions_for_knockouts_dataframe(df, outdir, threads, debug=False):
    """Runs secretion tree for the whole DataFrame.

    Arguments
    ---------

    df: A DataFrame generated by 1_run_sims.py.

    threads: The number of threads.

    debug: If True, then just run a single simulation.

    """
    loaded_models = load_models_to_compare(m_only=False)
    if debug:
        res = run_secretions_for_knockouts_series(df.loc[idx[['Atsumi2008-ao'], ['ME']], :].reset_index().iloc[0],
                                                  loaded_models=loaded_models,
                                                  outdir=outdir)
        out_df = pd.DataFrame([res]).set_index(df.index.names)
    else:
        out_df = apply_p(df, run_secretions_for_knockouts_series,
                         loaded_models=loaded_models, outdir=outdir,
                         threads=threads)
    out_df.to_pickle(join(outdir, 'secretion_tree_results.pickle'))

def run_secretions_for_knockouts_series(series, loaded_models=None, outdir=None):
    outfile = join(outdir, '%s_%s.json' % (series['paper'], series['model']))
    if exists(outfile):
        return pd.read_json(outfile, typ='series')

    # set up
    setup = setup_for_series(series, loaded_models, True)

    # do not knock out the genes in the model
    setup = SimulationSetup(
        setup.model,
        setup.environment,
        Design(setup.design.heterologous_pathway, [], setup.design.target_exchange),
        setup.use_greedy_knockouts
    )

    ignore_exchanges = ['EX_h2_e', 'EX_o2_e', 'EX_co2_e']
    try:
        results = secretions_for_knockouts(setup,
                                           raise_if_found=setup.design.target_exchange,
                                           ignore_exchanges=ignore_exchanges)
        out_series = pd.Series({
            'target_exchange': setup.design.target_exchange,
            'can_secrete': False,
            'data': results,
        })
    except FoundReaction:
        out_series = pd.Series({
            'target_exchange': setup.design.target_exchange,
            'can_secrete': True,
            'data': np.nan,
        })
    except SetUpModelError as e:
        return error_series(series, e)

    out_series['paper'] = series['paper']
    out_series['model'] = series['model']

    out_series.to_json(outfile)
    return out_series

def secretions_for_knockouts(setup, knockouts=[], max_depth=10, depth=0,
                             ignore_exchanges=[], raise_if_found=None,
                             growth_cutoff=min_biomass, flux_cutoff=0.1):
    """Accepts a SimulationSetup and a set of knockouts.

    Returns a tree of secretions using nested dictionaries.

    Arguments
    ---------

    setup: SimulationSetup.

    knockouts: A list of reaction IDs to knock out.

    max_depth: The maximum depth to search.

    depth: The current depth.

    ignore_exchanges: Exchanges to not knock out.

    raise_if_found: A reaction ID that, if found, will raise FoundReaction exception.

    growth_cutoff: Below this growth rate, the simulation is considered lethal.

    flux_cutoff: The minimum flux required to raise for raise_if_found.

    """
    # check depth
    if depth > max_depth:
        return None

    # always copy the model
    model = setup.model
    if model.id == 'ME':
        model = load_model(model.id)
    else:
        model = model.copy()

    # knock out the reactions by adding them to other_bounds
    for ko in knockouts:
        setup.environment.other_bounds[ko] = (0, 0)

    # set up model. Have to do this every time because the ME model cannot be
    # copied
    model = apply_environment(model, setup.environment)
    model = apply_design(model, setup.design, setup.use_greedy_knockouts)

    # solve the problem
    sol = me_optimize_growth(model) if model.id == 'ME' else model.optimize()
    if sol.f is None or sol.f <= growth_cutoff:
        return None
    else:
        secretion = dict(get_secretion(model, sol.x_dict, sort=False))
        if raise_if_found is not None and raise_if_found in secretion:
            fl = secretion[raise_if_found]
            if fl > flux_cutoff:
                raise FoundReaction(str(secretion))
        return {
            'knockouts': knockouts,
            'growth_rate': sol.f,
            'secretion': secretion,
            'children': {
                new_knockout: secretions_for_knockouts(setup, knockouts + [new_knockout],
                                                       max_depth, depth + 1,
                                                       ignore_exchanges, raise_if_found,
                                                       growth_cutoff, flux_cutoff)
                for new_knockout in secretion.iterkeys()
                if new_knockout not in ignore_exchanges
            }
        }


# def print_secretion(sec):
#     return '[f: %.2f | %s]' % (sec.growth_rate,
#                                ', '.join('%s: %.2f' % x for x in zip(sec.exchange_reactions, sec.fluxes)))


# def print_tree(tree, depth=0, format_data=lambda x: str(x)):
#     disp = ('   ' * depth)
#     out = '--> ' + format_data(tree['data']) + '\n'
#     for k, v in tree['children'].iteritems():
#         if type(v) is dict:
#             out += (disp + '|\n' + disp + ('\--%s%s' % (k, print_tree(v, depth + 1, format_data))))
#     #out += '\n'
#     return out
