"""Calculate the tree of all possible secretions if fermentation products are
sequentially knocked out.

"""

from me_scripts.hindsight.hindsight import (load_models_to_compare,
                                            get_secretion, setup_for_series,
                                            apply_design, apply_environment,
                                            error_series)
from me_scripts.hindsight.variables import min_biomass, SetUpModelError
from me_scripts.parallel_pandas import apply_p
from theseus import load_model

import pandas as pd
idx = pd.IndexSlice
import numpy as np
from collections import namedtuple
import sys

Secretions = namedtuple('Secretions', [
    'knockouts', # iterable
    'growth_rate', # float
    'exchange_reactions', # iterable
    'fluxes', # iterable with same order as exchange reactions
])
Secretions.__repr__ = lambda self: '<Secretions {self.knockouts}, {self.growth_rate:.3f}, {self.exchange_reactions}, {self.fluxes} >'.format(self=self)

class FoundReaction(Exception):
    pass

def run_secretions_for_knockouts_dataframe(df, threads, debug=False):
    """Runs secretion tree for the whole DataFrame.

    Arguments
    ---------

    df: A DataFrame generated by 1_run_sims.py.

    threads: The number of threads.

    debug: If True, then just run a single simulation.

    """
    loaded_models = load_models_to_compare(m_only=False)
    if debug:
        res = run_secretions_for_knockouts_series(df.loc[idx[:, ['e_coli_core']], :].reset_index().iloc[0],
                                                  loaded_models=loaded_models)
        out_df = pd.DataFrame([res]).set_index(df.index.names)
    else:
        out_df = apply_p(df, run_secretions_for_knockouts_series,
                         loaded_models=loaded_models, threads=threads)
    out_df.reset_index().to_json(sys.stdout)

def run_secretions_for_knockouts_series(series, loaded_models=None):
    # set up
    setup = setup_for_series(series, loaded_models, True)
    try:
        model = apply_environment(setup.model, setup.environment)
        model = apply_design(setup.model, setup.design, setup.use_greedy_knockouts)
    except SetUpModelError as e:
        return error_series(series, e)

    ignore_exchanges = ['EX_h2_e', 'EX_o2_e', 'EX_co2_e']
    try:
        results = secretions_for_knockouts(model,
                                           raise_if_found=setup.design.target_exchange,
                                           ignore_exchanges=ignore_exchanges)
        out_series = pd.Series({
            'target_exchange': setup.design.target_exchange,
            'can_secrete': False,
            'data': results,
        })
    except FoundReaction:
        out_series = pd.Series({
            'target_exchange': setup.design.target_exchange,
            'can_secrete': True,
            'data': np.nan,
        })
    out_series['paper'] = series['paper']
    out_series['model'] = series['model']
    return out_series

def secretions_for_knockouts(model, knockouts=[], max_depth=10, depth=0,
                             ignore_exchanges=[], raise_if_found=None,
                             growth_cutoff=min_biomass, flux_cutoff=0.1):
    """Accepts a model and a set of knockouts.

    Returns a tree of secretions using nested dictionaries.

    Arguments
    ---------

    model: The cobra model.

    knockouts: A list of reaction IDs to knock out.

    max_depth: The maximum depth to search.

    depth: The current depth.

    ignore_exchanges: Exchanges to not knock out.

    raise_if_found: A reaction ID that, if found, will raise FoundReaction exception.

    growth_cutoff: Below this growth rate, the simulation is considered lethal.

    flux_cutoff: The minimum flux required to raise for raise_if_found.

    """
    # check depth
    if depth > max_depth:
        return None

    # always copy the model
    if model.id == 'ME':
        model = load_model(model.id)
    else:
        model = model.copy()

    # knock out the reactions
    for ko in knockouts:
        model.reactions.get_by_id(ko).knock_out()

    # solve the problem
    solution = model.optimize()
    if solution.f is None or solution.f <= growth_cutoff:
        return None
    else:
        secretion = Secretions(knockouts, solution.f,
                               *zip(*get_secretion(model, solution.x_dict, sort=False)))
        if raise_if_found:
            if raise_if_found in secretion.exchange_reactions:
                index = secretion.exchange_reactions.index(raise_if_found)
                if secretion.fluxes[index] > flux_cutoff:
                    raise FoundReaction(str(secretion))
        return {
            'data': None if raise_if_found else secretion,
            'children': {
                new_knockout: secretions_for_knockouts(model, knockouts + [new_knockout],
                                                       max_depth, depth + 1,
                                                       ignore_exchanges, raise_if_found,
                                                       growth_cutoff, flux_cutoff)
                for new_knockout in secretion.exchange_reactions
                if new_knockout not in ignore_exchanges
            }
        }


# def print_secretion(sec):
#     return '[f: %.2f | %s]' % (sec.growth_rate,
#                                ', '.join('%s: %.2f' % x for x in zip(sec.exchange_reactions, sec.fluxes)))


# def print_tree(tree, depth=0, format_data=lambda x: str(x)):
#     disp = ('   ' * depth)
#     out = '--> ' + format_data(tree['data']) + '\n'
#     for k, v in tree['children'].iteritems():
#         if type(v) is dict:
#             out += (disp + '|\n' + disp + ('\--%s%s' % (k, print_tree(v, depth + 1, format_data))))
#     #out += '\n'
#     return out
